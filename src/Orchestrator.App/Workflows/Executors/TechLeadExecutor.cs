using Microsoft.Agents.AI.Workflows;
using Orchestrator.App.Core.Configuration;
using Orchestrator.App.Core.Models;
using Orchestrator.App.Parsing;
using Orchestrator.App.Utilities;

namespace Orchestrator.App.Workflows.Executors;

internal sealed class TechLeadExecutor : WorkflowStageExecutor
{
    public TechLeadExecutor(WorkContext workContext, WorkflowConfig workflowConfig) : base("TechLead", workContext, workflowConfig)
    {
    }

    protected override WorkflowStage Stage => WorkflowStage.TechLead;
    protected override string Notes => "TechLead spec generated.";

    protected override async ValueTask<(bool Success, string Notes)> ExecuteAsync(
        WorkflowInput input,
        IWorkflowContext context,
        CancellationToken cancellationToken)
    {
        // Check if we're in Q&A mode (answering a technical question) or spec generation mode
        var isQuestionAnswerMode = await IsQuestionAnswerModeAsync(context, cancellationToken);

        if (isQuestionAnswerMode)
        {
            return await AnswerTechnicalQuestionAsync(input, context, cancellationToken);
        }

        // Normal spec generation mode
        var playbook = await LoadPlaybookAsync();
        var template = WorkContext.Workspace.ReadOrTemplate(
            WorkflowPaths.SpecTemplatePath,
            WorkflowPaths.SpecTemplatePath,
            TemplateUtil.BuildTokens(WorkContext));
        if (string.IsNullOrWhiteSpace(template))
        {
            template = DefaultSpecTemplate;
        }

        var prompt = TechLeadPrompt.Build(input.WorkItem, playbook, template);
        var response = await CallLlmAsync(
            WorkContext.Config.TechLeadModel,
            prompt.System,
            prompt.User,
            cancellationToken);

        var specDraft = string.IsNullOrWhiteSpace(response) ? template : response;
        var specContent = TemplateUtil.EnsureTemplateHeader(specDraft, WorkContext, WorkflowPaths.SpecTemplatePath);
        var specPath = WorkflowPaths.SpecPath(input.WorkItem.Number);
        await FileOperationHelper.WriteAllTextAsync(WorkContext, specPath, specContent);

        var parsedSpec = new SpecParser().Parse(specContent);
        var (frameworks, patterns) = ResolvePlaybookUsage(playbook, specContent);
        var result = new TechLeadResult(specPath, parsedSpec, frameworks, patterns);
        var serializedResult = WorkflowJson.Serialize(result);
        await context.QueueStateUpdateAsync(WorkflowStateKeys.TechLeadResult, serializedResult, cancellationToken);
        WorkContext.State[WorkflowStateKeys.TechLeadResult] = serializedResult;

        // Commit the spec file (best effort - don't fail workflow if git fails)
        try
        {
            var branchName = $"issue-{input.WorkItem.Number}";
            var commitMessage = $"spec: Add technical specification for issue #{input.WorkItem.Number}\n\n" +
                               $"Generated by TechLead stage based on refinement and playbook constraints.";

            Logger.Debug($"[TechLead] Committing {specPath} to branch '{branchName}'");
            var committed = WorkContext.Repo.CommitAndPush(branchName, commitMessage, new[] { specPath });

            if (committed)
            {
                Logger.Info($"[TechLead] Committed and pushed spec to branch '{branchName}'");
            }
            else
            {
                Logger.Warning($"[TechLead] No changes to commit (spec unchanged)");
            }
        }
        catch (LibGit2Sharp.LibGit2SharpException ex)
        {
            Logger.Warning($"[TechLead] Git commit failed (continuing anyway): {ex.Message}");
        }
        catch (InvalidOperationException ex)
        {
            Logger.Warning($"[TechLead] Git commit failed (continuing anyway): {ex.Message}");
        }

        return (true, $"TechLead spec saved to {specPath}.");
    }

    private async Task<Playbook> LoadPlaybookAsync()
    {
        var content = await FileOperationHelper.ReadAllTextIfExistsAsync(WorkContext, WorkflowPaths.PlaybookPath) ?? "";
        return new PlaybookParser().Parse(content);
    }

    private static (IReadOnlyList<string> Frameworks, IReadOnlyList<string> Patterns) ResolvePlaybookUsage(Playbook playbook, string specContent)
    {
        var frameworks = playbook.AllowedFrameworks
            .Where(f => IsReferenced(specContent, f.Name) || IsReferenced(specContent, f.Id))
            .Select(f => f.Name)
            .Distinct(StringComparer.OrdinalIgnoreCase)
            .ToList();

        var patterns = playbook.AllowedPatterns
            .Where(p => IsReferenced(specContent, p.Name) || IsReferenced(specContent, p.Id))
            .Select(p => p.Name)
            .Distinct(StringComparer.OrdinalIgnoreCase)
            .ToList();

        return (frameworks, patterns);
    }

    private static bool IsReferenced(string content, string? value)
    {
        if (string.IsNullOrWhiteSpace(value))
        {
            return false;
        }

        return content.Contains(value, StringComparison.OrdinalIgnoreCase);
    }

    protected override WorkflowStage? DetermineNextStage(bool success, WorkflowInput input)
    {
        if (!success)
        {
            return null;
        }

        // If we just answered a question, go back to Refinement
        if (WorkContext.State.ContainsKey(WorkflowStateKeys.CurrentQuestionAnswer))
        {
            return WorkflowStage.Refinement;
        }

        // Normal flow: spec generation â†’ SpecGate
        return WorkflowStage.SpecGate;
    }

    private async Task<bool> IsQuestionAnswerModeAsync(IWorkflowContext context, CancellationToken cancellationToken)
    {
        var classificationJson = await context.ReadOrInitStateAsync(
            WorkflowStateKeys.QuestionClassificationResult,
            () => string.Empty,
            cancellationToken: cancellationToken);

        if (string.IsNullOrEmpty(classificationJson) && WorkContext.State.TryGetValue(WorkflowStateKeys.QuestionClassificationResult, out var fallback))
        {
            classificationJson = fallback;
        }

        if (string.IsNullOrEmpty(classificationJson))
        {
            return false;
        }

        if (!WorkflowJson.TryDeserialize(classificationJson, out QuestionClassificationResult? result) || result is null)
        {
            return false;
        }

        return result.Classification.Type == QuestionType.Technical;
    }

    private async ValueTask<(bool Success, string Notes)> AnswerTechnicalQuestionAsync(
        WorkflowInput input,
        IWorkflowContext context,
        CancellationToken cancellationToken)
    {
        Logger.Info($"[TechLead] Q&A mode: Answering technical question for issue #{input.WorkItem.Number}");

        // Get the question
        var classificationJson = await context.ReadOrInitStateAsync(
            WorkflowStateKeys.QuestionClassificationResult,
            () => string.Empty,
            cancellationToken: cancellationToken);

        if (string.IsNullOrEmpty(classificationJson) && WorkContext.State.TryGetValue(WorkflowStateKeys.QuestionClassificationResult, out var fallback))
        {
            classificationJson = fallback;
        }

        if (!WorkflowJson.TryDeserialize(classificationJson, out QuestionClassificationResult? classificationResult) || classificationResult is null)
        {
            Logger.Warning($"[TechLead] No classification result found");
            return (false, "TechLead Q&A failed: missing classification.");
        }

        var question = classificationResult.Classification.Question;
        Logger.Info($"[TechLead] Answering: {question}");

        // Get playbook and existing spec for context
        var playbook = await LoadPlaybookAsync();
        var existingSpec = await FileOperationHelper.ReadAllTextIfExistsAsync(WorkContext, WorkflowPaths.SpecPath(input.WorkItem.Number));

        // Build Q&A prompt
        var (systemPrompt, userPrompt) = BuildTechnicalQuestionPrompt(question, input.WorkItem, playbook, existingSpec);

        // Call LLM
        Logger.Debug($"[TechLead] Calling LLM for answer");
        var response = await CallLlmAsync(
            WorkContext.Config.TechLeadModel,
            systemPrompt,
            userPrompt,
            cancellationToken);

        Logger.Debug($"[TechLead] LLM response: {response}");

        // Parse answer
        if (!WorkflowJson.TryDeserialize(response, out TechnicalAnswer? result) || result is null)
        {
            Logger.Warning($"[TechLead] Failed to parse LLM response");
            return (false, "TechLead Q&A failed: could not parse answer.");
        }

        Logger.Info($"[TechLead] Answer generated");
        Logger.Debug($"[TechLead] Answer: {result.Answer}");

        // Store answer for Refinement to use
        await context.QueueStateUpdateAsync(WorkflowStateKeys.CurrentQuestionAnswer, result.Answer, cancellationToken);
        WorkContext.State[WorkflowStateKeys.CurrentQuestionAnswer] = result.Answer;

        return (true, "Technical question answered.");
    }

    private static (string System, string User) BuildTechnicalQuestionPrompt(
        string question,
        WorkItem workItem,
        Playbook playbook,
        string? existingSpec)
    {
        var system = "You are a Technical Lead in an SDLC workflow. " +
                     "Answer technical questions about implementation, architecture, patterns, and frameworks. " +
                     "Base your answers on best practices, playbook constraints, and existing specifications. " +
                     "If you cannot answer confidently, say so explicitly. " +
                     "Return JSON only.";

        var builder = new System.Text.StringBuilder();
        PromptBuilders.AppendIssueContext(builder, workItem);

        if (!string.IsNullOrWhiteSpace(existingSpec))
        {
            builder.AppendLine("Existing Specification:");
            builder.AppendLine(existingSpec);
            builder.AppendLine();
        }

        PromptBuilders.AppendPlaybookConstraints(builder, playbook);

        builder.AppendLine("Technical Question:");
        builder.AppendLine(question);
        builder.AppendLine();
        builder.AppendLine("Guidelines:");
        builder.AppendLine("- Answer based on best practices, playbook constraints, and existing spec");
        builder.AppendLine("- Focus on implementation details, architecture, patterns, frameworks");
        builder.AppendLine("- Be specific and actionable");
        builder.AppendLine("- If the answer is not clear, state 'CANNOT_ANSWER' in reasoning");
        builder.AppendLine();
        builder.AppendLine("Return JSON:");
        builder.AppendLine("{");
        builder.AppendLine("  \"question\": string (repeat the question),");
        builder.AppendLine("  \"answer\": string (your answer to the question),");
        builder.AppendLine("  \"reasoning\": string (brief explanation or 'CANNOT_ANSWER' if unsure)");
        builder.AppendLine("}");

        return (system, builder.ToString());
    }

    private sealed record TechnicalAnswer(string Question, string Answer, string Reasoning);

    private const string DefaultSpecTemplate =
        "# Spec: Issue {{ISSUE_NUMBER}} - {{ISSUE_TITLE}}\n\n" +
        "STATUS: DRAFT\n" +
        "UPDATED: {{UPDATED_AT_UTC}}\n\n" +
        "## Goal\n...\n\n" +
        "## Non-Goals\n- ...\n\n" +
        "## Components\n- ...\n\n" +
        "## Touch List\n| Operation | Path | Notes |\n| --- | --- | --- |\n| Modify | src/Example.cs | ... |\n\n" +
        "## Interfaces\n```csharp\n```\n\n" +
        "## Scenarios\nScenario: ...\nGiven ...\nWhen ...\nThen ...\n\n" +
        "Scenario: ...\nGiven ...\nWhen ...\nThen ...\n\n" +
        "Scenario: ...\nGiven ...\nWhen ...\nThen ...\n\n" +
        "## Sequence\n1. ...\n2. ...\n\n" +
        "## Test Matrix\n| Test | Files | Notes |\n| --- | --- | --- |\n| Unit | tests/ExampleTests.cs | ... |\n";
}
